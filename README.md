# Best-Fit-Worst-Fit-and-Next-Fit-Algorithms

This project presents a Java-based simulation of dynamic memory allocation techniques found in operating systems. It focuses on the Best Fit, Worst Fit, and Next Fit algorithms. The main goal of the project is to show how different allocation strategies impact memory use, fragmentation, and performance in managing a fixed-size memory space. By modeling memory as a mix of free and allocated blocks, the project offers a hands-on illustration of how operating systems manage memory allocation requests during runtime.

The simulation is written entirely in Java and uses a linked list structure to represent free memory blocks. Each block keeps track of its starting address and size. This setup allows the allocator to search, split, and merge memory regions as allocation and deallocation happen. The algorithm processes allocation requests, updating the memory's internal state accordingly. When memory is deallocated, it goes back to the free list, and the program tries to merge adjacent blocks to minimize fragmentation.

Three allocation strategies are implemented and compared. The Best Fit algorithm picks the smallest available free block that can meet a request. This method aims to reduce wasted space but often leads to increased external fragmentation. The Worst Fit algorithm allocates memory from the largest free block, leaving medium-sized blocks unallocated but possibly wasting large contiguous areas. The Next Fit algorithm, a variation of First Fit, continues searching from the last allocation point instead of starting from the beginning of the free list. This method can improve performance but may sacrifice optimal memory placement.

Besides implementing these algorithms, the project also has experimental components that test their behavior. It runs allocation and deallocation traces to mimic real memory usage patterns. The program measures execution time and fragmentation levels to compare how well each algorithm performs. The results appear in the console, allowing users to see how each strategy acts under the same workloads.

The codebase is arranged into multiple classes to enhance clarity and modularity. Memory blocks are shown as nodes in a linked list. A central allocator class includes the logic for the Best Fit, Worst Fit, and Next Fit operations. Allocation records track active memory use, while a comparison class performs automated tests and measures performance. This layout makes the project easy to understand, extend, and modify for further experiments.

In summary, this project acts as an educational resource for understanding dynamic memory allocation in operating systems. It suits students studying operating systems, memory management, or algorithm analysis. The project demonstrates how theoretical allocation strategies translate into practical implementations. It can also be expanded to include more allocation algorithms, graphical visualizations, or advanced fragmentation metrics, providing a solid foundation for further study and experimentation.
